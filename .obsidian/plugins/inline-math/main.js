/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NoMoreFlicker
});
module.exports = __toCommonJS(main_exports);
var import_state2 = require("@codemirror/state");
var import_obsidian2 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  disableInTable: false,
  disableDecorations: false,
  disableAtomicRanges: false
};
var NoMoreFlickerSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Disable in tables").setDesc("If turned on, braces won't be inserted in tables. Decorations & atomic ranges are enabled regardless of this setting.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableInTable).onChange(async (disable) => {
        this.plugin.settings.disableInTable = disable;
        await this.plugin.saveSettings();
      });
    });
    containerEl.createEl("h4", { text: "Debug mode" });
    new import_obsidian.Setting(containerEl).setName("Disable decorations").setDesc("If turned on, decorations to hide braces adjacent to dollar signs are disabled.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableDecorations).onChange(async (disable) => {
        this.plugin.settings.disableDecorations = disable;
        this.plugin.remakeViewPlugin();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Disable atomic ranges").setDesc(createFragment((el) => {
      el.createSpan({ text: 'If turned on, atomic ranges to treat "' });
      el.createEl("code", { text: "${} " });
      el.createSpan({ text: '" or "' });
      el.createEl("code", { text: " {}$" });
      el.createSpan({ text: '" as one character are disabled.' });
    })).addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disableAtomicRanges).onChange(async (disable) => {
        this.plugin.settings.disableAtomicRanges = disable;
        this.plugin.remakeViewPlugin();
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).addButton((button) => {
      button.setButtonText("Restore defaults").onClick(async () => {
        this.plugin.settings = Object.assign({}, DEFAULT_SETTINGS);
        await this.plugin.saveSettings();
        this.display();
      });
    });
  }
};

// src/handlers.ts
var import_language2 = require("@codemirror/language");

// src/utils.ts
var import_language = require("@codemirror/language");

// src/node_names.ts
var INLINE_MATH_BEGIN = "formatting_formatting-math_formatting-math-begin_keyword_math";
var MATH_END = "formatting_formatting-math_formatting-math-end_keyword_math_math-";

// src/utils.ts
function nodeText(node, state) {
  return state.sliceDoc(node.from, node.to);
}
function isInlineMathBegin(node, state) {
  return node.name == INLINE_MATH_BEGIN && nodeText(node, state) == "$";
}
function isInlineMathEnd(node, state) {
  return node.name == MATH_END && nodeText(node, state) == "$";
}
function selectionSatisfies(state, predicate) {
  let ret = false;
  const tree = (0, import_language.syntaxTree)(state);
  for (const { from, to } of state.selection.ranges) {
    const line = state.doc.lineAt(from);
    tree.iterate({
      from: line.from,
      to: line.to,
      enter: (node) => {
        if (predicate(node)) {
          ret = true;
        }
      }
    });
  }
  return ret;
}

// src/handlers.ts
function getChangesForDeletion(state) {
  const tree = (0, import_language2.syntaxTree)(state);
  const doc = state.doc.toString();
  const changes = [];
  for (const range of state.selection.ranges) {
    const from = range.empty ? range.from - 4 : range.from;
    const to = range.to;
    const text = state.sliceDoc(from, to);
    const index = text.lastIndexOf("$");
    if (index == -1) {
      continue;
    }
    const indexNextDollar = doc.indexOf("$", from + index + 1);
    const indexPrevDollar = doc.lastIndexOf("$", from);
    tree.iterate({
      from: indexPrevDollar,
      to: indexNextDollar >= 0 ? indexNextDollar : to,
      enter(node) {
        if (isInlineMathBegin(node, state) && state.sliceDoc(node.to, node.to + 3) == "{} ") {
          changes.push({ from: node.to, to: node.to + 3 });
        } else if (isInlineMathEnd(node, state) && state.sliceDoc(node.from - 3, node.from) == " {}") {
          changes.push({ from: node.from - 3, to: node.from });
        }
      }
    });
  }
  return changes;
}
function getChangesForInsertion(state) {
  const tree = (0, import_language2.syntaxTree)(state);
  const doc = state.doc.toString();
  let changes = [];
  for (const range of state.selection.ranges) {
    const indexNextDollar = doc.indexOf("$", range.to);
    const indexPrevDollar = doc.lastIndexOf("$", range.from);
    if (indexNextDollar >= 0) {
      tree.iterate({
        from: indexPrevDollar,
        to: indexNextDollar + 1,
        enter(node) {
          if (isInlineMathBegin(node, state)) {
            if (!(state.sliceDoc(node.to, node.to + 3) == "{} ")) {
              changes.push({ from: node.to, insert: "{} " });
            }
          } else if (isInlineMathEnd(node, state)) {
            if (!(state.sliceDoc(node.from - 3, node.from) == " {}")) {
              changes.push({ from: node.from, insert: " {}" });
            }
          }
        }
      });
    }
  }
  return changes;
}

// src/cleaner.ts
var import_language3 = require("@codemirror/language");
function cleaner(view) {
  const changes = [];
  (0, import_language3.syntaxTree)(view.state).iterate({
    enter(node) {
      if (isInlineMathBegin(node, view.state)) {
        if (view.state.sliceDoc(node.to, node.to + 3) == "{} ") {
          changes.push({ from: node.to, to: node.to + 3 });
        }
      } else if (isInlineMathEnd(node, view.state)) {
        if (view.state.sliceDoc(node.from - 3, node.from) == " {}") {
          changes.push({ from: node.from - 3, to: node.from });
        }
      }
    }
  });
  view.dispatch({ changes });
}
function cleanerCallback(editor) {
  const view = editor.cm;
  if (view) {
    cleaner(view);
  }
}

// src/decoration_and_atomic-range.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var import_language4 = require("@codemirror/language");
var DummyRangeValue = class extends import_state.RangeValue {
};
var createViewPlugin = (plugin) => import_view.ViewPlugin.fromClass(
  class {
    constructor(view) {
      this.impl(view);
    }
    update(update) {
      this.impl(update.view);
    }
    impl(view) {
      const decorationBulder = new import_state.RangeSetBuilder();
      const atomicRangeBulder = new import_state.RangeSetBuilder();
      const tree = (0, import_language4.syntaxTree)(view.state);
      for (const { from, to } of view.visibleRanges) {
        tree.iterate({
          from,
          to,
          enter(node) {
            if (isInlineMathBegin(node, view.state)) {
              if (view.state.sliceDoc(node.to, node.to + 3) == "{} ") {
                decorationBulder.add(
                  node.to,
                  node.to + 3,
                  import_view.Decoration.replace({})
                );
                atomicRangeBulder.add(
                  node.from,
                  node.to + 3,
                  new DummyRangeValue()
                );
              }
            } else if (isInlineMathEnd(node, view.state)) {
              if (view.state.sliceDoc(node.from - 3, node.from) == " {}") {
                decorationBulder.add(
                  node.from - 3,
                  node.from,
                  import_view.Decoration.replace({})
                );
                atomicRangeBulder.add(
                  node.from - 3,
                  node.to,
                  new DummyRangeValue()
                );
              }
            }
          }
        });
      }
      this.decorations = decorationBulder.finish();
      this.atomicRanges = atomicRangeBulder.finish();
    }
  },
  {
    decorations: (instance) => plugin.settings.disableDecorations ? import_view.Decoration.none : instance.decorations,
    provide: (viewPlugin) => import_view.EditorView.atomicRanges.of((view) => {
      var _a, _b;
      return plugin.settings.disableAtomicRanges ? import_state.RangeSet.empty : (_b = (_a = view.plugin(viewPlugin)) == null ? void 0 : _a.atomicRanges) != null ? _b : import_state.RangeSet.empty;
    })
  }
);

// src/main.ts
var NoMoreFlicker = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.viewPlugin = [];
  }
  async onload() {
    await this.loadSettings();
    await this.saveSettings();
    this.addSettingTab(new NoMoreFlickerSettingTab(this.app, this));
    this.registerEditorExtension(this.viewPlugin);
    this.remakeViewPlugin();
    this.registerEditorExtension(this.makeTransactionFilter());
    this.addCommand({
      id: "clean",
      name: "Clean up braces in this note",
      editorCallback: cleanerCallback
    });
    this.addCommand({
      id: "clean-all",
      name: "Clean up braces in all the opened notes",
      editorCallback: this.cleanAllMarkdownViews.bind(this)
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  makeTransactionFilter() {
    return import_state2.EditorState.transactionFilter.of((tr) => {
      if (this.shouldIgnore(tr.startState)) {
        return tr;
      }
      const userEvent = tr.annotation(import_state2.Transaction.userEvent);
      if ((userEvent == null ? void 0 : userEvent.split(".")[0]) == "input") {
        const changes = getChangesForInsertion(tr.startState);
        return [tr, { changes }];
      } else if ((userEvent == null ? void 0 : userEvent.split(".")[0]) == "delete") {
        const changes = getChangesForDeletion(tr.startState);
        return [tr, { changes }];
      }
      return tr;
    });
  }
  shouldIgnore(state) {
    return this.settings.disableInTable && selectionSatisfies(
      state,
      (node) => node.name.includes("HyperMD-table") || node.name.includes("hmd-table")
    );
  }
  cleanAllMarkdownViews() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view instanceof import_obsidian2.MarkdownView) {
        cleanerCallback(leaf.view.editor);
      }
    });
  }
  remakeViewPlugin() {
    this.viewPlugin.length = 0;
    this.viewPlugin.push(createViewPlugin(this));
    this.app.workspace.updateOptions();
  }
};
